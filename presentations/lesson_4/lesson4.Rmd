---
title: "Lesson 4: Introduction to Tidyverse"
author: "Ashir Borah and Natalie Elphick"
date: "October 29th, 2024"
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_dir = "../../docs/presentations"
    )
  })
output:
  revealjs::revealjs_presentation:
    theme: simple
    css: ../style.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      comment = "")
library(tidyverse)
library(gapminder)
```

## 

<center>Press the "?" key for tips on navigating these slides</center>

## Recap (key concepts so far)

- Variables, data types and data structures in R

- Functions (using, getting help, making your own)

- Loading and saving data

- Using Rstudio, Projects, and Markdown notebooks

- Working with data in vectors, lists, matrices, and dataframes (tables)

# Tidyverse

## Tidyverse

-   The tidyverse packages work well together because they share
common data representations and design principles
      -   Rows = Observations/Samples
      -   Columns = Variables/Measurements
-   [ggplot2](https://ggplot2.tidyverse.org/), for data visualization.
-   [dplyr](https://dplyr.tidyverse.org/), for data manipulation.
-   [tidyr](https://tidyr.tidyverse.org/), for data tidying.
-   [readr](https://readr.tidyverse.org/), for data import.
-   [purrr](https://purrr.tidyverse.org/), for iteration.
-   and more..


# Data Wrangling

## Data Wrangling

-   Turning messy data into useful statistics and visualizations

-   Taking some datasets (the 'nouns') and applying a series of transformations (the 'verbs')

-   These transformations are nessecary to create the format needed to create outputs (plots, summary tables etc.)




## Pipes

We often want to apply multiple functions ('verbs') to our data in a chain.

<img src="images/pipe_schematic.png" width = 85%>

`%>%` is a special R symbol for chaining together functions (part of `tidyverse`)


## Pipe Example

```{r, eval = FALSE}
# Hard to read
bop(scoop(hop(foo_foo, through = forest), up = field_mice), on = head)

# Creating unnecessary 'temporary' variables
foo_foo_1 <- hop(foo_foo, through = forest)
foo_foo_2 <- scoop(foo_foo_1, up = field_mice)
foo_foo_3 <- bop(foo_foo_2, on = head)
```

Using pipes makes your code easy to read and understand as a series of verbs 
```{r, eval = FALSE}
foo_foo %>%
  hop(through = forest) %>%
  scoop(up = field_mice) %>%
  bop(on = head)
```

## Pipe Example

Assigning the results of a chain to a new variable

```{r, eval = FALSE}
result <- input_data %>% function_1 %>% function_2
```


The pipe feeds the *first* argument of the next function

```{r}
x <- c('a', 'b', 'c')
x %>% c('d')
```

If you want the piped input to feed a different argument, you can use `.`:

```{r}
x %>% c('d', .)
```



## Why use pipes

- Code is easier to read (and modify)

- This style of coding is less prone to errors due to misplaced parentheses associated with nested function calls

- Using pipes is a choice! Use it when it's helpful

- Note: Rstudio keyboard shortcut: Cmd + shift + M

## Base R Pipe
-   Introduced in R 4.1.0, the base R pipe is represented by `|>`

-   It works similarly to %>% 


```{r}
x <- c('a', 'b', 'c')
x |> c('d')
```
Use `_` as a placeholder if the pipe output should go to a different argument:

```{r}
x |> rep(x = _, 2)
```
When using the placeholder `_` the arguement must be named.




# Data wrangling verbs


## dplyr
-    Offers a set of verbs for data manipulation   
      -    [mutate()](https://dplyr.tidyverse.org/reference/mutate.html) adds new variables that are functions of existing
    columns
      -    [select()](https://dplyr.tidyverse.org/reference/select.html) picks columns based on their names
      -    [filter()](https://dplyr.tidyverse.org/reference/filter.html) picks rows based on their values
      -    [summarise()](https://dplyr.tidyverse.org/reference/summarise.html) reduces multiple values down to a single summary
      -    [arrange()](https://dplyr.tidyverse.org/reference/arrange.html) changes the ordering of the rows
      -    [group_by()](https://dplyr.tidyverse.org/reference/group_by.html) allows any function above to be applied within a categorical grouping



## Gapminder package


```{r gapminder_setup}
#install.packages('gapminder')
library(gapminder)
```

```{r show_gapminder}
head(gapminder)
```


## Filter

- Select a subset of the rows from a tibble

- Arguments are the 'filters' you'd like to apply

```{r gapminder_year_filter}
gapminder %>% filter(year == 2007)
```

- Use `==` to pick rows with variable equal to a specified value.

## Logical operators for filtering

- Use `,` to check for multiple filters being true ('AND')

```{r gapminder_multiple_filter}
gapminder %>% 
  filter(year == 2002, continent == "Asia") %>% 
  sample_n(4)
```


## Logical operators for filtering

- Use `|` to check for any in multiple filters being true ('OR')

```{r gapminder_or_filter}
gapminder %>% 
  filter(year == 2002 | continent == "Asia") %>% 
  sample_n(4)
```


## Logical operators for filtering

- Use `%in%` to check if value is contained in a specified set

```{r gapminder_membership_filter}
gapminder %>% 
  filter(country %in% c("Argentina", "Belgium", "Mexico"),
         year %in% c(1987, 1992))
```



## select 

- Use `select` to pick a subset of columns by name

```{r gapminder_select}
gapminder %>% 
  select(country, year, lifeExp) %>% 
  head(4)
```

## Handling Columns with Non-standard Names

-   Select columns with non-standard names 
    -   Starts with number, special character or contains spaces
-   Use back-ticks (**not** single quotes), tab complete column names will do this for you

```{r gapminder_select_improper_names, eval = FALSE}
df %>% select(`1999`, `variable with spaces`)
```

## rename

- Use `rename` to rename certain columns
    -   Expected format: new name = old name

```{r gapminder_rename}
gapminder %>% 
  rename(lifeExpectancy = lifeExp, population = pop) %>% 
  head(3)
```

- Note that any column names you don't include are left unchanged


## arrange

- Reorder rows based on the values of one or more variables

```{r gapminder_arrange}
gapminder %>% 
  arrange(year) %>% 
  head(4)
```

## arrange

- Sorting by multiple variables

```{r gapminder_arrange_multiple}
gapminder %>% 
  arrange(year, lifeExp) %>% 
  head(4)
```


## desc

- Can also sort in descending order

```{r gapminder_desc_arrange}
gapminder %>%
  filter(year > 2000) %>%
  arrange(desc(country)) %>%
  head(4)
```


## mutate

- **Create a new variable with a specific value**
- Create a new variable that is a function of existing variables
- Overwrite the contents of an existing variable
  
```{r gapminder_mutate}
gapminder %>% 
  mutate(just_one = 1) %>% 
  head(4)
```

## mutate

- Create a new variable with a specific value 
- **Create a new variable that is a function of existing variables**
- Overwrite the contents of an existing variable
  
```{r gapminder_mutate_arithmetic}
gapminder %>%
  mutate(gdp = pop * gdpPercap) %>% 
  head(4)
```


## mutate

- Create a new variable with a specific value 
- Create a new variable that is a function of existing variables
- **Overwrite the contents of an existing variable**
  
```{r gapminder_mutate_change_var}
gapminder %>%
  mutate(pop = pop/1e6) %>% 
  head(4)
```

## mutate and ifelse 

```{r}
x <- 10
ifelse(x > 9, "x is greater than 9", "x is not greater than 9")
```

Allows you to use mutate in a 'condition-dependent' way

```{r}
gapminder %>% 
  mutate(adjusted_gdp = ifelse(year < 1980, gdpPercap * 2, gdpPercap)) %>% 
  sample_n(5)
```


## summarise

- Apply a numerical summary to a column of a table

```{r gapminder_summarise}
gapminder %>% 
  filter(year == 1997) %>% 
  summarise(max_exp = max(lifeExp),
            sd_exp = sd(lifeExp))
```

- Works with any functions that take a vector as input and return a single value


## group_by

- Combined with `summarise`, `group_by` allows you to summarise data for each possible value of a categorical variable

```{r gapminder_groupby}
gapminder %>% 
  filter(year == 1997) %>% 
  group_by(continent) %>%
  summarise(max_exp = max(lifeExp),
            sd_exp = sd(lifeExp))
```

## group_by {.smaller}

- Can be applied to combinations of variables

```{r gapminder_groupby_multiple}
gapminder %>% 
  group_by(continent, year) %>%
  summarise(num_rows = n(),
            max_exp = max(lifeExp),
            sd_exp = sd(lifeExp)) %>% 
  head(4)
```

- `n()` function counts number of rows in each group


# Recap

<img src="images/dplyr_visual.png" width="100%">

[dplyr cheat sheet](https://posit.co/wp-content/uploads/2022/10/data-transformation-1.pdf)

## Additional resources

- [dplyr intro](https://dplyr.tidyverse.org/articles/dplyr.html)

- More on pipes: [DataCamp](https://www.datacamp.com/community/tutorials/pipe-r-tutorial), 
[TowardsDataScience](https://towardsdatascience.com/an-introduction-to-the-pipe-in-r-823090760d64)



# ChatGPT/LLMs Tips for R

## General Tips

-   Follow [UCSF's institutional guidelines](https://ai.ucsf.edu/ucsf-ai-guidance) on using LLMs
-   Always **critically review** the outputs of LLMs
-   Provide **as much detail as possible** about the problem in the 1st prompt
-   Use separate chats for separate tasks/projects
-   Commented R code yields better responses
-   Never input sensitive data into an LLM

## When to use LLMs?

-   To help you understand coding concepts by providing examples and explanations
-   To reformat or optimize code that already works
-   To explain what someone else's code is doing
-   To write **small** amounts of code that you can test easily

<u>Over-reliance on LLMs to write your code can prevent you from learning the basics.</u>

## Coding with LLMs Tips

-   LLMs have a limited context (memory)
    -   If you query them long enough they "forget"
-   Provide short blocks of code (fewer than 200 lines)
-   Works best on single functions instead of whole code files
-   Include in the 1st prompt the kinds of code outputs you want
    -   "Output short blocks of commented code"
    -   "Output only the code you modified"
    -   "Make minimal changes to fix the issue"

## Prompt Engineering

-   Developing and optimizing prompts to get the desired outputs from LLMs
-   **Zero-shot**: the prompt does not contain examples
-   **Few-shot**: the prompt contains a few examples of responses
-   **Chain-of-thought**: Few-shot but the examples explain their reasoning

This is an on-going field of active research, see this [guide](https://www.promptingguide.ai/techniques) for more techniques.


## Recap

-   Avoid over-reliance on LLMs
-   Provide lots of details about the problem in the 1st prompt
-   If the outputs do not make sense then try different styles of prompting





